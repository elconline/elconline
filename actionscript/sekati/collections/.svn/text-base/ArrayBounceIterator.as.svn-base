/** * sekati.collections.ArrayBounceIterator * @version 1.0.1 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.collections {	import sekati.collections.IIterator;	import sekati.collections.IPointerIterator;	/**	 * ArrayBounceIterator provides a non-destructive, pointer-based, bouncing Array Iterator 	 * which iterates to the end of the array then reverses direction backward & forward.	 */	public class ArrayBounceIterator implements IIterator, IPointerIterator {		protected var _array : Array;		protected var _pointer : int;		protected var _isForward : Boolean;		protected var _isSkipRepeat : Boolean;		/**		 * ArrayBounceIterator Constructor		 * @param array 			of collection elements.		 * @param skipDuplicate 	if <code>true</code> iterate <code>'0,1,2,1,0'</code> rather than <code>'0,1,2,2,1,0'</code>.		 */		public function ArrayBounceIterator(array : Array, isSkipRepeat : Boolean = true) {			_array = array.concat( );			_isSkipRepeat = isSkipRepeat;			reset( );		}		/**		 * Returns the next element, or <code>null</code> if none.		 */		public function next() : Object {			var p : int = movePointer( );			return hasNext( ) ? _array[p] : null;		}				/**		 * Return the current element		 */		public function current() : Object {			return _array[_pointer];		}		/**		 * Reset iterative pointer index.		 */		public function reset() : void {			_pointer = -1;			_isForward = true;		}			/**		 * We always have a next element as we bounce at each iteration end.		 */		public function hasNext() : Boolean {			return true;		}				/**		 * Return a <code>peek</code> of the next element without 		 * directionally iterating the pointer forwards, or return		 * <code>null</code> if none.		 */		public function peek() : Object {			return _array[movePointer( true )];		}		/**		 * Move the pointer in the proper direction; bounce at either end.		 * @param isPreview 	if <code>true</code> the pointer will not be iterated; but will return a preview pointer index.		 */		protected function movePointer(isPreview : Boolean = false) : int {			var p : int = _pointer;			if (_isForward) {				if(p < _array.length - 1) {					p++;				} else {					_isForward = false;					var restep : int = (_isSkipRepeat) ? 2 : 1;					p = _array.length - restep;					}			} else {				if (p > 0) {					p--;				} else {					_isForward = true;					p = (_isSkipRepeat) ? 1 : 0;				}			}			if (!isPreview) {				_pointer = p;				}			return p;		}		/**		 * Return the collection length.		 */		public function get length() : int {			return _array.length;		}		/**		 * The interative pointer index.		 */		public function get pointer() : int {			return _pointer;		}		/**		 * @private		 */		public function set pointer(i : int) : void {			_pointer = i;		}					}}