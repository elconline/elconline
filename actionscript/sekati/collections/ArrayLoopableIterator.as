/** * sekati.collections.ArrayLoopableIterator * @version 1.1.0 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.collections {	import sekati.collections.ArrayBidirectionalIterator;	import sekati.collections.ILoopableIterator;	import sekati.collections.IPointerIterator;		/**	 * ArrayLoopableIterator provides a non-destructive, pointer-based, Looping Bi-Directional Array Iterator.	 */	public class ArrayLoopableIterator extends ArrayBidirectionalIterator implements ILoopableIterator, IPointerIterator {		/**		 * ArrayLoopableIterator Constructor		 */		public function ArrayLoopableIterator(array : Array) {			super( array );		}		/**		 * Override: ArrayLoopableIterator starts at end upon interating to the begining.		 */		override public function previous() : Object {			if (_pointer > 0) {				return super.previous( );			} else {				_pointer = _array.length - 1;				return _array[_pointer];			}		}		/**		 * Override: ArrayLoopableIterator starts at beginning once iteration completes.		 * @return Object		 */		override public function next() : Object {			if (_pointer < _array.length - 1) {				return super.next( );			} else {				super.reset( );				return super.current( );			}		}				/**		 * Override: ArrayLoopableIterator always has a next element.		 */		override public function hasPrevious() : Boolean {			return true;		}			/**		 * Override: ArrayLoopableIterator always has a previous element.		 */		override public function hasNext() : Boolean {			return true;		}			/**		 * Return a <code>glimple</code> of the previous element without 		 * directionally iterating the pointer backwards.		 */		override public function glimpse() : Object {			if (_pointer > 0) {				return super.glimpse( );				} else {				return _array[_array.length - 1];			}		}		/**		 * Return a <code>peek</code> of the next element without 		 * directionally iterating the pointer forwards.		 */		override public function peek() : Object {			if (_pointer < _array.length - 1) {				return super.peek( );			} else {				return _array[0];			}		}		/**		 * Return <code>true</code> if pointer is at the begining of the collection.		 */		public function isAtStart() : Boolean {			return (_pointer == 0);		}		/**		 * Return <code>true</code> if pointer is at the end of the collection.		 */		public function isAtEnd() : Boolean {			return (_pointer == _array.length - 1);		}	}}