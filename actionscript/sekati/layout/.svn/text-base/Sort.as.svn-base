/** * sekati.layout.Sort * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.layout {	import flash.display.DisplayObject;	import flash.geom.Point;	import sekati.display.StageDisplay;	import sekati.math.MathBase;		/**	 * Sort provides various visual sorting arrangements for arrays of <code>DisplayObject</code>'s.	 */	public class Sort {		protected var _items : Array;		protected var _sort : Array;		/**		 * Sort Constructor		 * @param items 	Array of DisplayObjects		 * @throws Error 	if any element in items array is not a DisplayObject.		 * @example <listing version="3.0">		 * var sort : Sort = new Sort( [do0, do1, do2, do3] );		 * </listing>		 */		public function Sort(items : Array) {			for (var i : int = 0; i < items.length ; i++) {				if(!items[i] is DisplayObject) {					throw new Error( "@@@ sekati.layout.Sort Error: constructor expects 'items' argument array to contain only DisplayObjects." );					return;				}			}			_items = items;			_sort = new Array( );					}		/**		 * Sort items in a grid.		 * @param start  	Point to begin positioning.		 * @param numPerRow items per row.		 * @param offset 	spacing between items.		 * @return Array	of sort Point positions.		 * @example <listing version="3.0">		 * var positions : Array = new Sort( itemArr ).grid( new Point( 100, 100 ), 10, 1 );		 * </listing>		 */			public function grid(start : Point, numPerRow : uint, offset : Number = 0) : Array {			var _xpos : Number = 0;			var _ypos : Number = 0;					// if there is no _width,_height lets assume the items are Points and count them as one pixel.			var _w : Number = (!_items[0].width) ? 1 : _items[0].width;			var _h : Number = (!_items[0].height) ? 1 : _items[0].height;			var _numPerRow : Number = (!numPerRow) ? Math.ceil( (StageDisplay.$.width - start.x) / (_w + offset) ) : numPerRow;					for (var i : int = 0; i < _items.length ; i++) {				if ((i % _numPerRow) == 0) {					_xpos = offset;					_ypos += _h + offset;				} else {					_xpos += _w + offset;					_ypos += 0;				}				_sort[i] = new Point( Math.round( _xpos ) + start.x, Math.round( _ypos ) + start.y );			}			return _sort;				}		/**		 * Sort items in a circle.		 * @param center 	Point to radiate from.		 * @param radius  	of the circle sort.		 * @return Array 	of Point positions.		 * @example <listing version="3.0">		 * var positions : Array = new Sort( itemArr ).circle( new Point( 250, 250 ), 255 );		 * </listing>		 */		public function circle(center : Point, radius : Number) : Array {			for (var i : int = 0; i < _items.length ; i++) {				var angle : Number = i * (360 / _items.length);				var x : Number = Math.round( (center.x + (radius * Math.cos( (angle - 180) * Math.PI / 180 ))) );				var y : Number = Math.round( (center.y + (radius * Math.sin( (angle - 180) * Math.PI / 180 ))) );				_sort[i] = new Point( x, y );			}			return _sort;		}		/**		 * Sort items in a sine wave.		 * @param waves  		number of waves to sort within.		 * @param width 		each sine waves width.		 * @param yPos 			sine wave y position. 		 * @param widthCap 		use n percent of the width.		 * @param heightCap 	use n percent of the height.		 * @return Array 		of Point positions.		 * @example <listing version="3.0">		 * var positions : Array = new Sort( itemArr ).sine( 1.5, StageDisplay.$.width, StageDisplay.$.height / 2, 0.9, 0.5 );		 * </listing>		 */		public function sine(waves : uint, width : Number, yPos : Number, widthCap : Number, heightCap : Number) : Array {			var _degStep : Number = (waves * 2 * Math.PI) / (_items.length - 1);			var _xStep : Number = (width * widthCap) / _items.length;			for (var i : int = 0; i < _items.length ; i++) {				var x : Number = Math.round( (width - width * widthCap) / 2 + _xStep * i );				var y : Number = Math.round( Math.sin( _degStep * i ) * yPos * heightCap + yPos );				_sort[i] = new Point( x, y );			}			return _sort;		}		/**		 * Sort items in a triangle.		 * @param center 		Point to center sort on.		 * @param sideLength 	of each triangle side.		 * @return Array 		of Point positions.		 * @example <listing version="3.0">		 * var positions : Array = new Sort( itemArr ).triangle( new Point( 250, 250 ), 500 );		 * </listing>		 */		public function triangle(center : Point, sideLength : Number) : Array {			var cY : Number = center.y - (sideLength / 2);			var objBySide : Number = Math.floor( _items.length / 3 );			var leftObj : Number = _items.length - objBySide * 3;			var posArray : Array = new Array( );			var radAngle : Number = Math.PI / 3;			var spacing : Number;						for (var i : int = 0; i < _items.length ; i++) {				posArray[i] = new Point( );				if (i < objBySide) {					spacing = sideLength / objBySide;					posArray[i].x = (spacing * i) * Math.cos( radAngle );					posArray[i].y = (spacing * i) * Math.sin( radAngle );				}				if (i >= objBySide && i < objBySide * 2 + Math.ceil( leftObj / 2 )) {					spacing = (leftObj != 0) ? sideLength / (objBySide + 1) : sideLength / objBySide;					posArray[i].x = (sideLength * Math.cos( radAngle )) - (spacing * (i - objBySide));					posArray[i].y = sideLength * Math.sin( radAngle );				}				if (i >= objBySide * 2 + Math.ceil( leftObj / 2 )) {					spacing = (leftObj == 2) ? sideLength / (objBySide + 1) : sideLength / objBySide;					posArray[i].x = -sideLength * Math.cos( radAngle ) + (spacing * (i - (objBySide * 2 + Math.ceil( leftObj / 2 )))) * Math.cos( radAngle );					posArray[i].y = sideLength * Math.sin( radAngle ) - (spacing * (i - (objBySide * 2 + Math.ceil( leftObj / 2 )))) * Math.sin( radAngle );				}				var x : Number = Math.round( center.x + posArray[i].x );				var y : Number = Math.round( cY + posArray[i].y );				_sort[i] = new Point( x, y );			}			return _sort;		}		/**		 * Sort items in a flower.		 * @param center 	Point to sort from.		 * @param radius 	of each petal.		 * @return Array 	of Point positions.		 * @example <listing version="3.0">		 * var positions : Array = new Sort( itemArr ).flower( new Point( 250, 250 ), 250 );		 * </listing>		 */			public function flower(center : Point, radius : Number) : Array {			var posArray : Array = new Array( );			var step : Number = (2 * Math.PI) / _items.length;			var b : Number = 1;			var k : Number = 2;			for (var i : int = 0; i < _items.length ; i++) {				var r : Number = b * Math.cos( k * i * step );				posArray[i] = new Point( );				posArray[i].x = (r * Math.cos( i * step )) * radius;				posArray[i].y = (r * Math.sin( i * step )) * radius;				var x : Number = Math.round( center.x + posArray[i].x );				var y : Number = Math.round( center.y + posArray[i].y );				_sort[i] = new Point( x, y );			}			return _sort;		}		/**		 * Sort items in hedron (star, square, triangle, hexagon, octagon, etc).		 * @param center 			Point to sort from.		 * @param corners 			to create.		 * @param heightCap 		use n percent of the height.		 * @param rotate  			of the sort.		 * @param isIntraRadial 	if <code>true</code> star shapes will be drawn else closed hedrons.		 * @return Array of Point positions.		 * @example <listing version="3.0">		 * var positions : Array = new Sort( itemArr ).hedron( new Point( 250, 250 ), 8, 0.6, 90 ); // create a octagon and rotate 90 degrees.		 * </listing>		 */		public function hedron(center : Point, corners : uint, heightCap : Number = 0.8, rotate : uint = 0, isIntraRadial : Boolean = false) : Array {			var outerRadius : Number = center.y * heightCap;			var innerRadius : Number = (!isIntraRadial) ? outerRadius * Math.sqrt( (1 + Math.cos( (2 * Math.PI) / corners )) / 2 ) : outerRadius / 2;			var cursors : Number = _items.length;			var lines : Number = corners * 2;			var cursorsPerLine : Number = Math.floor( cursors / lines );			var cursorsLeftOver : Number = cursors - cursorsPerLine * lines; 			// cursors for adoption...			var alphaStep : Number = (2 * Math.PI) / corners;			rotate = (Math.PI / 180) * rotate;			var alpha : Number = rotate;			var actualCursor : Number = 0;			var cursorsOnActualLine : Number;			var xStep : Number;			var yStep : Number;			var xAct : Number;			var yAct : Number;	    			for (var i : int = 0; i < corners ; i++) {				var xOuter1 : Number = Math.sin( alpha ) * outerRadius;				var yOuter1 : Number = Math.cos( alpha ) * outerRadius;				var xInner : Number = Math.sin( alpha - alphaStep / 2 ) * innerRadius;				var yInner : Number = Math.cos( alpha - alphaStep / 2 ) * innerRadius;				var xOuter2 : Number = Math.sin( alpha - alphaStep ) * outerRadius;				var yOuter2 : Number = Math.cos( alpha - alphaStep ) * outerRadius;				// plot first line				cursorsOnActualLine = cursorsPerLine;				if (cursorsLeftOver > 0) {					cursorsOnActualLine++; 					// add one of the left over cursors on the line					cursorsLeftOver--; // one was adopted!				}				xStep = (xInner - xOuter1) / cursorsOnActualLine;				yStep = (yInner - yOuter1) / cursorsOnActualLine;				xAct = center.x + xOuter1;				yAct = center.y + yOuter1;				for (var j : int = 0; j < cursorsOnActualLine ; j++) {					_sort[actualCursor] = new Point( int( xAct ), int( yAct ) );					xAct += xStep;					yAct += yStep;					actualCursor++;				}				// plot second line				cursorsOnActualLine = cursorsPerLine;				if (cursorsLeftOver > 0) {					cursorsOnActualLine++; 					// add one of the left over cursors on the line					cursorsLeftOver--; // another one was adopted!				}				xStep = (xOuter2 - xInner) / cursorsOnActualLine;				yStep = (yOuter2 - yInner) / cursorsOnActualLine;				xAct = center.x + xInner;				yAct = center.y + yInner;				for (var k : int = 0; k < cursorsOnActualLine ; k++) {					_sort[actualCursor] = new Point( int( xAct ), int( yAct ) );					xAct += xStep;					yAct += yStep;					actualCursor++;				}				alpha -= alphaStep;			}			return _sort;		}		/**		 * Sort items in a Star shape.		 * @param center 		Point to sort from.		 * @param corners 		to create.		 * @param heightCap 	use n percent of the height.		 * @param rotate 		of the sort.		 * @return Array of Point positions.		 * @see Sort#hedron		 * @example <listing version="3.0">		 * var positions : Array = new Sort( itemArr ).star( new Point( 250, 250 ), 0.6, 5, 180 );		 * </listing>		 */		public function star(center : Point, corners : uint = 5, heightCap : Number = 0.8, rotate : uint = 0) : Array {			return hedron( center, corners, heightCap, rotate, true );		}		/**		 * Sort items in a square.		 * @param center 		Point to sort from.		 * @param heightCap 	use n percent of the height.		 * @return Array of Point positions.		 * @see Sort#hedron		 * @example <listing version="3.0">		 * var positions : Array = new Sort( itemArr ).square( new Point( 250, 250 ), 0.8 );		 * </listing>		 */		public function square(center : Point, heightCap : Number = 0.8) : Array { 			return hedron( center, 4, heightCap, 225 ); 		}		/**		 * Sort items in a hexagon.		 * @param center 		Point to sort from.		 * @param heightCap 	use n percent of the height.		 * @return Array of Point positions.		 * @see Sort#hedron		 * @example <listing version="3.0">		 * var positions : Array = new Sort( itemArr ).hexagon( new Point( 250, 250 ) );		 * </listing>		 */		public function hexagon(center : Point, heightCap : Number) : Array { 			return hedron( center, 6, heightCap, 90 );		}		/**		 * Unsort items in to a random arrangement.		 * @param topLeft 		arrangement confine.		 * @param bottomLeft 	arrangement confine.		 * @return Array of Point positions.		 * @example <listing version="3.0">		 * var positions : Array = new Sort( itemArr ).unsort( new Point( 0, 0 ), new Point( StageDisplay.$.width, StageDisplay.$.height ) );		 * </listing>		 */		public function unsort(topLeft : Point, bottomRight : Point) : Array {			for (var i : int = 0; i < _items.length ; i++) {				_sort[i] = new Point( MathBase.random( topLeft.x, bottomRight.x ), MathBase.random( topLeft.y, bottomRight.y ) );			}			return _sort;		}					}}