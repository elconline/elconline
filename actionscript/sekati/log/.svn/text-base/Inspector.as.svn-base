/** * sekati.log.Inspector * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2008 jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.log {	/**	 * Recursive Object Inspector	 */	public class Inspector {		private var _result : String;		/**		 * Constructor		 */		public function Inspector(...args) {			_result = "";			recurse.apply( this, args );		}		/**		 * Recursively stringify objects contents		 * @param obj (Object) target object		 * @param path (String) optional path to prepend for verbose output		 * @param level (Number) optional level		 * @param maxPathLength (Number) optional max path to be used with padding		 * @return void		 */			private function recurse(obj : Object, path : String = "", level : Number = 0, maxPathLength : Number = 10) : void {			var padding : String;			var paddingChar : String = " ";			var parentType : String;			var currentType : String;			var newPath : String;			//var maxPathLength:Number = paddingRecursion( obj, path ) + 3;			//maxPathLength (only defined initially)   			if (isNaN( maxPathLength )) {				maxPathLength = paddingRecursion( obj, path ) + 3;			}			//calculate parents type   			parentType = (obj is Array) ? "array" : typeof (obj);			for (var i:String in obj) {				//calculate path				newPath = (parentType == "array") ? path + "[" + i + "]" : path + "." + i;				//calculate this type				currentType = (obj[i] is Array) ? "array" : typeof (obj[i]);				//find how much padding is needed for this item to print				padding = "";				for (var j : Number = 0; j < maxPathLength - newPath.length ; j++) {					padding += paddingChar;				}				_result += (newPath + padding + obj[i] + "  (" + currentType + ")\n");				//go deeper				recurse( obj[i], newPath, level + 1, maxPathLength );			}		}		/**		 * Recurse through everything to find what the biggest path string 		 * will be - strictly for formatting purposes.		 */		private function paddingRecursion(obj : Object, path : String, longestPath : Number = 0) : Number {			var parentType : String;			//calculate parents type   			parentType = (obj is Array) ? "array" : typeof (obj);			for (var i:String in obj) {				//this levels path				var newPath : String = (parentType == "array") ? path + "[" + i + "]" : path + "." + i;				if (newPath.length > longestPath) {					longestPath = newPath.length;				}				//outside recursion   				var outsideRecursion : Number = paddingRecursion( obj[i], newPath, longestPath );				if (outsideRecursion > longestPath) {					longestPath = outsideRecursion;				}			}			return longestPath;		}		/**		 * Return the result		 */		public function toString() : String {			return _result;			}			}}