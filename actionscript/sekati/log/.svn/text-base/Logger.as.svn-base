/** * sekati.log.Logger * @version 1.2.1 * @author jason m horwitz | sekati.com * Copyright (C) 2008 jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.log {	import flash.events.EventDispatcher;	import sekati.events.LogEvent;	import sekati.log.ILogger;	import sekati.log.Inspector;	import sekati.log.LogLevel;	import sekati.log.LogTarget;	import sekati.reflect.ClassReflector;	import sekati.utils.StopWatch;	import sekati.validators.TypeValidator;		/**	 * Logger provides a common logging facility for applications implementing the API.	 */	final public class Logger extends EventDispatcher implements ILogger {		public static var _instance : Logger;		private static var _logId : uint = 1;		private static var _isEnabled : Boolean = true; 		private var _levels : Object;		private var _filters : Array;		private var _watch : StopWatch;		private var _outputMode : uint;		/**		 * Logger Singleton Constructor		 * @param $ SingletonEnforcer - internal to the AS file; the param prevents external instantiation without error.		 */		public function Logger( $ : SingletonEnforcer = null) {			if (!$) {				throw new ArgumentError( "sekati.log.Logger is a Singleton and may only be accessed via its accessor methods: 'getInstance()' or '$'." );				}			_watch = new StopWatch( true );			// we set a default target until the user sets one.			outputMode = LogTarget.ALL;			resetLevels( );			resetFilters( );			}		/**		 * Singleton Accessor		 * @return Logger		 */		public static function getInstance() : Logger {			if( _instance == null ) _instance = new Logger( new SingletonEnforcer( ) );			return _instance;		}		/**		 * Shorthand singleton accessor getter		 * @return Logger		 */		public static function get $() : Logger {			return Logger.getInstance( );			}		// CORE LOGGING				/**		 * <code>trace</code> is a log level denoting a standard log event.		 */			public function trace(origin : Object, message : String) : void {			log( LogLevel.TRACE, origin, message );		}		/**		 * <code>info</code> is a log level denoting an informational event.		 */		public function info(origin : Object, message : String) : void {			log( LogLevel.INFO, origin, message );		}		/**		 * <code>status</code> is a log level denoting a status message.		 */		public function status(origin : Object, message : String) : void {			log( LogLevel.STATUS, origin, message );		}		/**		 * <code>notice</code> is a log level denoting an event of interest.		 */		public function notice(origin : Object, message : String) : void {			log( LogLevel.NOTICE, origin, message );		}		/**		 * <code>debug</code> is a log level denoting an informational event which may require investigation.		 */		public function debug(origin : Object, message : String) : void {			log( LogLevel.DEBUG, origin, message );		}		/**		 * <code>warn</code> is a log level denoting an event of concern.		 */		public function warn(origin : Object, message : String) : void {			log( LogLevel.WARN, origin, message );		}		/**		 * <code>error</code> is a log level denoting a error type event.		 */		public function error(origin : Object, message : String) : void {			log( LogLevel.ERROR, origin, message );		}		/**		 * <code>fatal</code> is a log level denoting a fatal type event.		 */		public function fatal(origin : Object, message : String) : void {			log( LogLevel.FATAL, origin, message );		}		/**		 * <code>object</code> is a special log level which delivers origin object recursion.		 * @see sekati.log.Inspector		 */		public function object(origin : Object) : void {			var message : String = new Inspector( origin ).toString( );			log( LogLevel.OBJECT, origin, message );		}		/**		 * Output handler dispatcher the fully assembled <code>LogEvent</code>.		 */		private function log(level : uint, origin : Object, message : String) : void {			if (enabled == false || outputMode == LogTarget.NONE || _levels[level] == false || isFiltered( origin ) == true) {				return;			}			var context : String = (!TypeValidator.isPrimitive( origin )) ? new ClassReflector( origin ).qualifiedName : String( typeof origin );			var benchmark : uint = _watch.lap( );			var id : uint = _logId++;			var msg : String = (outputMode == LogTarget.IDE || outputMode == LogTarget.FIREBUG || outputMode == LogTarget.ALL ) ? id + " \t" + LogLevel.resolveLevelName( level ).toUpperCase( ) + " \t" + context + " \t" + message + " \t(" + benchmark + " ms)" : '';						if (outputMode == LogTarget.IDE || outputMode == LogTarget.ALL) {				LogTarget.updateIDE( msg );			}						if (outputMode == LogTarget.FIREBUG || outputMode == LogTarget.ALL) {				LogTarget.updateFirebug( LogLevel.resolveFirebugLevelName( level ), msg );			}						// dispatch a LogEvent if ALL is set in case there are application hooks.			if (outputMode == LogTarget.ALL) {				var timestamp : String = new Date( ).toLocaleTimeString( );				dispatchEvent( new LogEvent( LogEvent.LOG_EVENT, id, level, context, message, benchmark, timestamp ) );			}		}		// CORE CONTROLLERS				/**		 * @private		 */			public function get enabled() : Boolean {			return _isEnabled;		}		/**		 * Logger enabled status.		 */		public function set enabled(b : Boolean) : void {			_isEnabled = b;		}		/**		 * @private		 */		public function get outputMode() : uint {			return _outputMode;		}		/**		 * Handles which output mode(s) the <code>Logger</code> should act upon.		 * @see sekati.log.LogTarget		 */		public function set outputMode(mode : uint) : void {			if (mode < LogTarget.NONE || mode > LogTarget.ALL ) {				throw new ArgumentError( "An invalid mode value was set to Logger.$.outputMode." );				} else {				_outputMode = mode;				}		}		/**		 * Returns level and filter settings.		 */		public function get settings() : String {			return getLevels( ) + "\n" + getFilters( );		}		/**		 * Reset our default levels and filters.		 */		public function reset() : void {			setAllLevels( true );			resetFilters( );		}		// LEVEL HANDLERS				/**		 * Enable/disable a log level.		 * @param level 	level name		 * @param isEnabled 	enabled status		 */		public function setLevel(level : String, isEnabled : Boolean) : void {			_levels[level.toLowerCase( )] = isEnabled;		}		/**		 * Enable or disable all existing levels.		 * @param isEnabled 	enabled status		 */		public function setAllLevels(isEnabled : Boolean) : void {			for (var i:String in _levels) {				setLevel( _levels[i], isEnabled );			}		}		/**		 * Reset all levels		 */		public function resetLevels() : void {			_levels = {trace:true, info:true, status:true, notice:true, debug:true, warn:true, error:true, fatal:true, object:true};		}		/**		 * Returns a stringified overview of all levels statuses.		 */		public function getLevels() : String {			var a : Array = new Array( );			for (var i:String in _levels) {				a.push( i + ":" + _levels[i].toString( ) );			}			return "_levels={" + a.toString( ) + "};";		}					// FILTER HANDLERS			/**		 * Enable/disable a filter and create the filter if it does not already exist.		 * @param origin 	object to filter on [usually a string]		 * @param isFiltered		 */		public function setFilter(origin : Object, isFiltered : Boolean) : void {			if (isFiltered) {				filter( origin );			} else {				unfilter( origin );			}		}		/**		 * Returns a stringified overview of all filters statuses.		 */		public function getFilters() : String {			return "_filters=[" + _filters.toString( ) + "];";		}		/**		 * Reset all filters (clearing previous filters)		 */		public function resetFilters() : void {			_filters = [];		}		/**		 * Check if an origin's output is being filtered		 * @param origin 	to check.		 */		public function isFiltered(origin : Object) : Boolean {			var o : String = String( origin );			for (var i : Number = 0; i < _filters.length ; i++) {				if (_filters[i] == o) {					return true;				}			}			return false;		}			/**		 * Add an origin to the filters array.		 * @param origin 	to be added.		 */		private function filter(origin : Object) : void {			var o : String = String( origin );			if (!isFiltered( o )) {				_filters.push( o );			}		}		/**		 * Remove an origin from the filters array.		 * @param origin 	to be removed.		 */		private function unfilter(origin : Object) : void {			var o : String = String( origin );			for (var i : Number = 0; i < _filters.length ; i++) {				if (_filters[i] == o) {					_filters.splice( i, 1 );					break;				}			}		}		/**		 * Destroy the Logger Singleton instance.		 */				public function destroy() : void {			_watch.destroy( );			reset( );			_instance = null;		}	}}/** * Internal class is accessible only to this AS file and is used  * as a constructor param to enforce proper Singleton behavior. */internal class SingletonEnforcer {}