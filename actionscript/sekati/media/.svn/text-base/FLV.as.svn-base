/** * sekati.media.FLV * @version 1.2.3 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.media {	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.NetStatusEvent;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import sekati.events.FramePulse;	import sekati.events.MediaEvent;			/**	 * FLV provides a common media control object.	 * 	 * @see sekati.events.MediaEvent	 * @see sekati.ui.FLVPlayer	 */	public class FLV extends EventDispatcher {		protected var _this : FLV;		protected var _ns : NetStream;		protected var _nc : NetConnection;		protected var _client : Object;		protected var _video : Video;		protected var _url : String;		protected var _paused : Boolean;		protected var _started : Boolean;		protected var _duration : Number;		protected var _metadata : Object;		protected var _lastSeekableTime : Number;		protected var _bufferTime : Number;		protected var _bufferPause : Boolean;				/**		 * FLV Constructor		 */		public function FLV(width : int = 320, height : int = 240, smoothing : Boolean = true) {			super( );			_this = this;			_paused = false;			_started = false;			// fix for buffer bar flakiness			_duration = 1000000000;			_video = new Video( width, height );			_video.smoothing = smoothing;		}		/**		 * Load the video and begin playback.		 * @param url 		of the FLV to be loaded.		 * @param buffer 	seconds of buffer to maintain.		 */		public function load(url : String, buffer : uint = 4) : void {			_url = url;			_nc = new NetConnection( );			_nc.connect( null );			_client = new Object( );			_ns = new NetStream( _nc );			_video.attachNetStream( _ns );			/* The standard NS.bufferTime will fire cuePoints out of order			 * so we will utilize a smart-buffer we build ourselves.			 * @see http://www.restlessthinker.com/blog/?p=44			 * // _ns.bufferTime = buffer; 			 */			_bufferTime = buffer;			//			 			_ns.client = _this;			_ns.addEventListener( NetStatusEvent.NET_STATUS, ns_onStatus, false, 0, true );			_client['onMetaData'] = ns_onMetaData;			_client['onCuePoint'] = ns_onCuePoint;						_ns.client = _client;			//start to load movie, pause and put on first frame to see something			play( );			stop( );			FramePulse.$.addFrameListener( ns_onProgress );		}		// BASIC CONTROLLERS				/**		 * begin playback.		 */		public function play() : void {			_started = true;			_ns.play( _url );		}		/**		 * stop playback.		 */		public function stop() : void {			//_ns.togglePause( );			_ns.pause( );			_started = false;			_paused = false;		}		/**		 * pause playback.		 */		public function pause() : void {			if (!_paused && _started) {				_paused = true;				_ns.togglePause( );			}		}		/**		 * resume playback.		 */		public function resume() : void {			if (_paused && _started) {				_paused = false;				_ns.togglePause( );			}		}		/**		 * pause/resume playback toggle.		 */		public function pauseResume() : void {			if (_paused) {				resume( );			} else {				pause( );			}		}		/**		 * seek to a playback time.		 * @param time in playback to seek to.		 */		public function seek(time : Number) : void {			_ns.seek( resolveTime( time ) );		}		/**		 * seek to a playback percent (1 based %).		 * @param percent of playback to seek to.		 */		public function seekToPercent(percent : Number) : void {			seek( _duration * percent / 1 );		}		/**		 * fast-forward playback.		 * @param step seconds to step forward.		 */		public function ff(step : Number = 2) : void {			seek( getTime( ) + step );		}		/**		 * rewind playback.		 * @param step seconds to step backwards.		 */		public function rew(step : Number = 2) : void {			seek( getTime( ) - step );		}		// STATUS UTILITIES				/**		 * Check if the FLV is paused.		 */		public function isPaused() : Boolean {			return _paused;		}		/**		 * Check if the FLV is playing.		 */		public function isPlaying() : Boolean {			return _started;		}		/**		 * Check if the FLV is stopped.		 */		public function isStopped() : Boolean {			return !_started;		}		/**		 * Return the playback time.		 */		public function getTime() : Number {			return _ns.time;		}		/**		 * Return the total playback duration.		 */		public function getDuration() : Number {				return _duration;		}		/**		 * Return the percent played (1 based %). 		 */		public function getPercentPlayed() : Number {			return getTime( ) * 1 / _duration;		}		// PRELOAD UTILITIES				/**		 * Return the percent loaded (1 based %).		 */		public function getPercentLoaded() : Number {			return ( _ns.bytesLoaded / _ns.bytesTotal );		}		/**		 * Return the percent buffered (1 based %).		 */		public function getPercentBuffered() : Number {			// removed for smart-buffering			//var total : Number = Math.min( _duration, _ns.bufferTime );			var total : Number = Math.min( _duration, _bufferTime );			//return Math.min( Math.round( _ns.bufferLength / total * 1 ), 100 );			return _ns.bufferLength / total;		}		// AUDIO & VIDEO GETTER				/**		 * Set the video volume		 * @param volume 0-1		 */		public function setVolume(volume : Number) : void {			var st : SoundTransform = _ns.soundTransform;			st.volume = volume;			_ns.soundTransform = st;					}		/**		 * <code>FLV Video</code> instance. Made available		 * so clients may attach to Display List.		 */		public function get video() : Video {			return _video;			}		/**		 * <code>FLV Netstream</code> instance. Made available		 * if clients wish to listen to <code>NetStream</code>		 * events directly instead of the more pragmatic but 		 * less granular <code>MediaEvent</code>.		 */		public function get ns() : NetStream {			return _ns;			}		/**		 * Stop playback and cleanup after self.		 */		public function destroy() : void {			stop( );			FramePulse.$.removeFrameListener( ns_onProgress );			_ns.removeEventListener( NetStatusEvent.NET_STATUS, ns_onStatus );			_video.clear( );			_ns.close( );			_nc.close( );			_video = null;			_ns = null;			_nc = null;			_client = null;		}		/**		 * Formats time so that it fits inside the available seek scope.		 */		protected function resolveTime(time : Number) : Number {			var maxTime : Number = (!isNaN( _lastSeekableTime )) ? _lastSeekableTime : _duration;			return Math.max( Math.min( time, maxTime ), 0 );		}		/**		 * Handle buffer externally to <code>ns.bufferTime</code> so we can achieve proper cuePoint timing.		 */		protected function checkBuffer() : void {			// outta buffer!			if(getPercentLoaded( ) <= getPercentBuffered( )) {				// VIDEO HAS FINISHED PLAYING				if(getPercentLoaded( ) >= 1) {					return; 				}				// pause playback				_bufferPause = true;				dispatchEvent( new MediaEvent( MediaEvent.REBUFFER ) );			} else {				if(_bufferPause) {					// resume playback					_bufferPause = false;					dispatchEvent( new MediaEvent( MediaEvent.REBUFFER_COMPLETE ) );				}			}					}		// PROGRESS, NETSTREAM & NETCONNECTION EVENT HANDLERS		/**		 * Progress frame loop to keep client progress up to date.			 */		protected function ns_onProgress(e : Event) : void {			dispatchEvent( new MediaEvent( MediaEvent.PROGRESS, null, getPercentLoaded( ), getPercentPlayed( ) ) );			checkBuffer( );		}		/**		 * NetStatus handler.		 */		protected function ns_onStatus(stats : NetStatusEvent) : void {			trace( "netstat: " + stats.info['code'] );			switch (stats.info['code']) {				case "NetStream.Buffer.Empty" :					dispatchEvent( new MediaEvent( MediaEvent.BUFFER_EMPTY, "bufferEmpty" ) );					break;				case "NetStream.Buffer.Full" :					dispatchEvent( new MediaEvent( MediaEvent.BUFFER_FULL, "bufferFull" ) );					break;				case "NetStream.Buffer.Flush" :					dispatchEvent( new MediaEvent( MediaEvent.BUFFER_FLUSH, "bufferFlush" ) );					break;				case "NetStream.Play.Start" :					dispatchEvent( new MediaEvent( MediaEvent.START, "start" ) );					break;				case "NetStream.Play.Stop" :					dispatchEvent( new MediaEvent( MediaEvent.STOP, "stop" ) );					break;				case "NetStream.Play.StreamNotFound" :					dispatchEvent( new MediaEvent( MediaEvent.STREAM_NOT_FOUND, "play_streamNotFound" ) );					break;				case "NetStream.Seek.InvalidTime" :					dispatchEvent( new MediaEvent( MediaEvent.SEEK_INVALID_TIME, "seek_InvalidTime" ) );					break;				case "NetStream.Seek.Notify" :					dispatchEvent( new MediaEvent( MediaEvent.SEEK_NOTIFY, "seek_notify" ) );					break;				default :					trace( "Unrecognized NetStatusEvent value: " + stats.info['code'] );					dispatchEvent( new MediaEvent( MediaEvent.UNRECOGNIZED, stats.info['code'] ) );			}					}		/**		 * Net CuePoint handler.		 */		protected function ns_onCuePoint(infoObject : Object) : void { 			dispatchEvent( new MediaEvent( MediaEvent.CUE_POINT, MediaEvent.CUE_POINT, NaN, NaN, null, infoObject ) );		  	/*			for (var propName:String in infoObject) {				if (propName != "parameters") {					trace( propName + " = " + infoObject[propName] );				}		        else {					trace( "parameters =" );					if (infoObject['parameters'] != undefined) {						for (var paramName:String in infoObject['parameters']) {							trace( paramName + ": " + infoObject['parameters'][paramName] );						}					}		            else {						trace( "undefined" );					}				} 			}			 */		}				/**		 * Net MetaData handler.		 */		protected function ns_onMetaData(metadata : Object) : void {			trace( "metadata: " + metadata['duration'] );			_duration = metadata['duration'];			_lastSeekableTime = metadata['lastkeyframetimestamp'];			_metadata = metadata;			// dispatch metadata to clients			dispatchEvent( new MediaEvent( MediaEvent.METADATA, MediaEvent.METADATA, NaN, NaN, metadata ) );			//depends on which application was used to encode the FLV file			trace( "ns_onMetaData event at " + _ns.time );			/*			SORENSON - INITIAL META:			creationdate - Mon Jun 12 16:21:12 2006 			framerate - 29.9699859619141			audiocodecid - 2			audiodatarate - 64			videocodecid - 5			canSeekToEnd - false			videodatarate - 600			height - 358			width - 150			duration - 17.65			 */			//find what metadata is available now			/*			for (var i in metadata) {				trace( i + " - " + metadata[i] );			}			//trace cuepoints			for (var j:String in metadata.cuePoints) {				trace( "CUEPOINTS: " + j + " - " + metadata.cuePoints[j] );				for (var k:String in metadata.cuePoints[j]) {					trace( "  CUEPOINTS: " + k + " - " + metadata.cuePoints[j][k] );				}			}			*/					}							}}