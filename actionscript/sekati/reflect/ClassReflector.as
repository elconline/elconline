/** * sekati.reflect.ClassReflector * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php *  * Portions of this class were adapted from di-as3. */package sekati.reflect {	import flash.utils.describeType;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;		import sekati.reflect.MethodReflector;	import sekati.utils.ArrayPeer;		/**	 * ClassReflector provides a centralized class reflection API.	 */	public class ClassReflector {		private var _qualifiedName : String;		private var _type : Class;		private var _description : XML;		private var _interfaces : Array;		private var _superClasses : Array;		private var _methods : Array;		private var _properties : Array;		private var _propertiesAndMethods : Array;		/**		 * ClassReflector Constructor		 * @param o - Class or class instance to be reflected.		 */		public function ClassReflector(o : Object) {			_qualifiedName = getQualifiedClassName( o );			_type = (o is Class) ? (o as Class) : getDefinitionByName( _qualifiedName ) as Class;			if( !_type ) throw new ArgumentError( 'Not class or definition not found, received:' + o );			_description = describeType( _type );		}		/** 		 * The class that was reflected		 */		public function get type() : Class {			return _type;		}			/**		 * The output of describeType		 */		public function get description() : XML {			return _description;		}		// inheritence				/**		 * The fully qualified class name		 */		public function get qualifiedName() : String {			return description.@name;		}		/**		 * The class name without namespaces		 */		public function get shortName() : String {			return qualifiedName.split( '::' ).pop( );		}		/**		 * The package the Class is in		 */		public function get packageName() : String {				return qualifiedName.split( '::' ).shift( );		}		/**		 * Interfaces the Class implements		 */		public function get interfaces() : Array {			if( !_interfaces ) {				var interfaceQualifiedNames : XMLList = description["factory"].implementsInterface.@type;				_interfaces = [];				for each( var interfaceName:XML in interfaceQualifiedNames ) {					_interfaces.push( getDefinitionByName( interfaceName ) );				}			}			return _interfaces;		}		/**		 * Classes the class extends		 */		public function get superClasses() : Array {			if( !_superClasses ) {				var superclassQualifiedNames : XMLList = description["factory"].implementsInterface.@type;				_superClasses = [];				for each( var className:XML in superclassQualifiedNames ) {					_superClasses.push( getDefinitionByName( className ) );				}			}			return _superClasses;		}		// methods, properties, variables				/**		 * Constructor description		 */		public function get constructor() : MethodReflector {			return ( isConcrete ) ? new MethodReflector( this, description["factory"].constructor[0] ) : null;		}		/**		 * Instance method descriptions		 */		public function get methods() : Array {			if( !_methods ) {				_methods = [];				for each( var method:XML in description["factory"].method ) {					_methods.push( new MethodReflector( this, method ) );				}			}			return _methods;					}		/**		 * Instance Properties and Variables		 */		public function get properties() : Array {			if( !_properties ) {				_properties = [];				for each( var prop:XML in description["factory"].accessor ) {					_properties.push( new MethodReflector( this, prop ) );				}				for each( var variable:XML in description["factory"].variable ) {					_properties.push( new MethodReflector( this, variable ) );				}			}			return _properties;		}			/**		 * All MethoddInfo instances for the properties, variables and methods of an instance of the reflected class		 */		public function get propertiesAndMethods() : Array {			if( !_propertiesAndMethods ) {				_propertiesAndMethods = properties["concat"].apply( properties, methods );			}			return _propertiesAndMethods;		}		/**		 * Search for a method with the specified name and return its MethodReflector		 *		 * @param name The method name to search for		 * @return The MethodReflector for the method if it exists		 */		public function method( name : String ) : MethodReflector {			return ArrayPeer.findFirst( methods, {name: name } );		}		/**		 * Search for a property or variable with the specified name and return its MethodReflector		 *		 * @param name The property or variable name to search for		 * @return The MethodReflector for the property if it exists		 */		public function property( name : String ) : MethodReflector {			return ArrayPeer.findFirst( properties, { name: name } );		}		/**		 * Search for a getter (property, variable or method) with the specified name and return its MethodReflector		 *		 * @param name The getter name to search for		 * @return The MethodReflector for the getter if it exists		 */		public function getter( name : String ) : MethodReflector {			// search methods, properties, and variables for /(get)?name/i			var getter : MethodReflector = ArrayPeer.findFirst( propertiesAndMethods, { name: new RegExp( '^((?:get)?' + name + ')$', 'i' ) } ) as MethodReflector;						if( getter && (getter.returnType || getter.readable) ) return getter;						// or if dynamic return a MethodReflector instance with null(ish) values;			// and set the return type to * 			// note: due to the way describeType works if provided with a Class we cannot determine this accurately 			if( isDynamic ) {				// todo: implement (kind of tricky given that describeType lies to us about the dynamicism of classes)				// todo: return a MethodReflector object with a fake description that would be gettable				return null;			}						return null;		}			/**		 * Search for a setter (property, variable or method) with the specified name and return its MethodReflector		 *		 * @param name The setter name to search for		 * @return The MethodReflector for the setter if it exists		 */		public function setter( name : String ) : MethodReflector {			// search methods, properties, and variables for /(set)?name/i			var setter : MethodReflector = ArrayPeer.findFirst( propertiesAndMethods, {name: new RegExp( '^((?:set)?' + name + ')$', 'i' )} ) as MethodReflector;						if( setter && ((setter.callable && setter.parameters.length > 0) || setter.writable) ) return setter;						// or if dynamic return a MethodReflector instance with null(ish) values;			// and set the return type to * 			// note: due to the way describeType works if provided with a Class we cannot determine this accurately 						if( isDynamic ) {				// todo: implement (kind of tricky given that describeType lies to us about the dynamicism of classes)				// todo: return a MethodReflector object with a fake description that would be gettable				return null;			}						return null;					}		/**		 * Is this class marked as final		 */		public function get isFinal() : Boolean {			return description.@isFinal == 'true' ? true : false;		}		/**		 * Indicates if the Class is dynamic		 * <p>note: flash.utils.describeType lies to us and only returns the correct answer if you use describeType on an instance of a class, not the class itself. Until a workaround is found this function will always returns false.</p>		 */		public function get isDynamic() : Boolean {			//return description.@isDynamic == 'true' ? true : false;				return false;		}		/**		 * Is this a Class or an interface?		 */		public function get isConcrete() : Boolean {			// todo: perhaps also check for <constructor /> node ?			return ( description["factory"][0].extendsClass.length( ) > 0 ) ? true : false;		}		/**		 * Is this Class an interface?		 */		public function get isInterface() : Boolean {			return ( description["factory"][0].extendsClass.length( ) == 0 ) ? true : false;		}		// type inheritance		/*public function isSuperClassOf( type:Class ):Boolean		{		// todo: implement isSuperClassOf		return false;		}*/				/**		 * Indicates if the reflected class is a subclass of the supplied class		 */		public function isSubClassOf( type : Class ) : Boolean {				return superClasses.indexOf( type ) > -1 ? true : false;		}		/**		 * Indicates if the reflected class implements the supplied type		 */		public function isImplementorOf( type : Class ) : Boolean {			if( this.type === type ) return true;			return ( isSubClassOf( type ) );		}		public function toString() : String {			return '[ClassInfo ' + qualifiedName + ']';		}										}}