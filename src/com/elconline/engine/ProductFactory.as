/** * com.mac.engine.ProductFactory * @version 2.2.3 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package com.coresite.engine {	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.utils.Dictionary;	import com.doubleprime.generic.GenericJsonRpc;	import com.coresite.engine.*;	import Engine;	/**	 * ProductFactory provides the core JSON communication layer between the <code>Engine</code>	 * and the Mac provided <code>GenericFlash</code> and <code>GenericFlashRpc</code> database quering classes.	 * 	 * <p>Usually the client application will load the <code>Engine</code> DLL via the <code>EngineConnector</code> 	 * class then request specific product categories from the <code>ProductFactory</code></p>	 * 	 * @see com.mac.engine.ProductCollection	 * @see com.mac.engine.ProductCategory	 * @see com.mac.engine.ProductItem	 * @see com.mac.engine.ProductSku	 */	final public class ProductFactory extends EventDispatcher {		/**		 * Complete list of JSON Category queriable fields		 */		// original		//protected static const CATEGORY_FIELDS : Array = [ 'cat_base_id', 'category_name', 'mnemonic' ];		// old		//protected static const CATEGORY_FIELDS : Array = [ 'CATEGORY_ID', 'DISPLAY_NAME', 'basename', 'product', 'category' ];			// lite deprecated		//protected static const CATEGORY_FIELDS_LITE : Array = [ 'CATEGORY_ID', 'DISPLAY_NAME', 'basename', 'product', 'category' ];		// XXX - NEW: 08.21.08 | REMOVED UNUSED: 'mnemonic'		// XXX - NEW: 11.10.08 | CHANGED: 'display_name' to 'category_name'		protected static const CATEGORY_FIELDS : Array = [ 'category_id', 'category_name', 'image_name', 'category', 'product' ];		/**		 * Complete list of JSON Product queriable fields		 */		// original 		//protected static const PRODUCT_FIELDS : Array = [ 'prod_base_id', 'prod_rgn_name', 'prod_cat_image_name', 'description', 'sku', ];		// old		//protected static const PRODUCT_FIELDS : Array = [ 'PRODUCT_ID', 'PRODUCT_NAME', 'IMAGE_NAME', 'DESCRIPTION', 'finishes_by_product', 'sku' ];		// lite deprecated		//protected static const PRODUCT_FIELDS_LITE : Array = [ 'PRODUCT_ID', 'PRODUCT_NAME', 'IMAGE_NAME', 'DESCRIPTION', 'finishes_by_product', 'sku' ];		// XXX - NEW: 08.21.08 | UNUSED: 'product_type'		// XXX - NEW: 11:04.08 | ADDED: 'default_cat_id' for coremetrics tracking		protected static const PRODUCT_FIELDS : Array = [ 'product_id', 'name', 'description', 'finishes_by_product', 'image_base', 'sku','flash_desc', 'default_cat_id' ];				/**		 * Complete list of JSON SKU queriable fields (now includes TENDER custom fields: 'area_id' thru 'lightness')		 */		// original		//protected static const SKU_FIELDS : Array = [ 'sku_base_id', 'Hex_Value', 'upc_code', 'prod_cat_image_name', 'Smoosh_Design', 'price', 'product_size', 'product_code', 'ShadeName', 'shade_description', 'inventory_status', 'display_status', 'area_of_face', 'coverage', 'fibre', 'finish_simple', 'product_form', 'product_type', 'undertone', 'use', 'use_with' ];		// old 		/*		protected static const SKU_FIELDS : Array = [ 'SKU_ID', 'HEX_VALUE', 'UPC_CODE', 'IMAGE_BASE', 'SUB_HEADING', 'SMOOSH_DESIGN', 'SHORT_DESC', 'DESCRIPTION',  'LOWER_DESC', 'FEATURES', 		'SHADE_GROUP', 'EL_SKIN_TYPE_DRY', 'EL_SKIN_TYPE_COMBO', 'EL_SKIN_TYPE_OILY', 'BENEFITS', 'PRODUCT_PRICE', 'PRODUCT_SIZE', 		'PRODUCT_CODE', 'SHADENAME', 'SHADE_DESCRIPTION','FINISH', 'INVENTORY_STATUS', 'shopping_id', 'shoppable',		'area_id', 'product_type_id', 'product_form_id', 'coverage_id', 'finish_id', 'undertone_id', 'use_id', 'use_with_id', 'fibre_id', 'benefit_id', 'intensity' ];		 */		// light deprecated		//protected static const SKU_FIELDS_LITE : Array = [ 'SKU_ID', 'HEX_VALUE', 'IMAGE_BASE', 'SMOOSH_DESIGN' ];		// intermediary deprecated		//protected static const SKU_FIELDS_NEW : Array = [ 'prod_rgn_id', 'prod_rgn_name', 'prod_base_name', 'description' ];		// OOO - NEW: 08.21.08 | UNUSED: [?] 		protected static const SKU_FIELDS : Array = [ 'sku_id', 'finish', 'hex_values', 'inventory_status', 'path', 'price', 'product_code', 'shade_description', 		'shadename', 'size', 'smoosh_design', 'upc_code', 'area_of_face', 'coverage', 'fibre', 'finish_simple', 'intensity', 'product_form', 'flash_desc',		'product_type', 'undertone', 'use', 'use_with' ];		/**		 * Singleton instance		 */		protected static var _instance : ProductFactory;		/**		 * The raw JSON response data from the last query		 */		protected var _data : * = null;		/**		 * Intermediary storage for <code>ProductCategory</code> objects which are part of a collection queries		 */		protected var _queryCollectionData : * = null;		/**		 * Array of category id's to query during a sequential getProductCollection call.		 */		protected var _queryCollectionCat : Array;		/**		 * The index of the next category id to be loaded in the collection query.		 */		protected var _queryCollectionPointer : int = -1;		/*** @private */		protected var _queryArgs : Array;		/*** @private */		protected var _queryResultHandler : Function;		/*** @private */		protected var _isQuerying : Boolean = false;		/*** @private */		protected var _attempts : int = 0;		/*** @private */ 		protected static const MAX_ATTEMPTS : int = 3;				protected static var ROOT_CATEGORY : String;		/**		 * ProductFactory Singleton Constructor		 * @param $ SingletonEnforcer - internal to the AS file; the param prevents external instantiation without error.		 */		public function ProductFactory( $ : SingletonEnforcer = null) {			if (!$) {				throw new ArgumentError( "ProductFactory is a Singleton and may only be accessed via its accessor methods: 'getInstance()' or '$'." );				}			trace( "ProductFactory Singleton Instantiated ..." );		}
		/**		 * Singleton Accessor		 * @return ProductFactory		 */		public static function getInstance() : ProductFactory {			if( _instance == null ) _instance = new ProductFactory( new SingletonEnforcer( ) );			return _instance;		}
		/**		 * Shorthand singleton accessor getter		 * @return ProductFactory		 */		public static function get $() : ProductFactory {			return ProductFactory.getInstance( );			}
		//---------------------------------------------------------------------------		// QUERIABLE PUBLIC CALLS		/**		 * Load a specified product and all of its sku's.		 * @param productId		of the product		 * @example <listing version="3.0">		 * 		ProductFactory.$.getProductItem( 'CATEGORY27264PROD12686' );		 * 		ProductFactory.$.addEventListener( EngineEvent.QUERY_ITEM_INIT, itemHandler );		 * 				 * 		function itemHandler(e : Event) : void {		 * 			ProductFactory.$.removeEventListener( EngineEvent.QUERY_ITEM_INIT );		 * 			var myItem : ProductItem = e['data']; // contains the result ProductItem.		 * 		}		 * </listing>		 * @see #getProductCategory()		 */		public function getProductItem(productId : String) : void {			trace( "... getProduct() ..." );			/*			var productFields : Array = (!isLite) ? PRODUCT_FIELDS : PRODUCT_FIELDS_LITE;			var skuFields : Array = (!isLite) ? SKU_FIELDS : SKU_FIELDS_LITE;			// exclude stock_status_message (garbage html), exclude: HEX_VALUE (should be all strings, some are number types!)			var args : Array = [ { product: [ productId ], product_fields: productFields, sku_fields: skuFields } ];			 */			var args : Array = [ { product: [ productId ], product_fields: PRODUCT_FIELDS, sku_fields: SKU_FIELDS } ]; 			queryRPC( args, itemResultHandler );		}	
		/**		 * Load a specificied product category and all of its ProductItems and sku's: returned in the dispatched <code>EngineEvent.CATEGORY_INIT</code> event.		 * @param categoryId 	of the category		 * @example <listing version="3.0">		 * ProductFactory.$.getProductCategory( "CATEGORY27264" );		 * ProductFactory.$.addEventListener( EngineEvent.QUERY_CATEGORY_INIT, categoryHandler );		 * 		 * function categoryHandler(e : Event) : void {		 *  	ProductFactory.$.removeEventListener( EngineEvent.QUERY_CATEGORY_INIT );		 *  	var myCategory : ProductCategory = e['data']; // contains the result ProductCategory.		 * }		 * </listing>		 * @see #getProductCollection()		 */		public function getProductCategory(categoryId : String) : void {			trace( "ProductFactory.$.getProductCategory( " + categoryId + " ) ..." );			/*			var categoryFields : Array = (!isLite) ? CATEGORY_FIELDS : CATEGORY_FIELDS_LITE;			var productFields : Array = (!isLite) ? PRODUCT_FIELDS : PRODUCT_FIELDS_LITE;			var skuFields : Array = (!isLite) ? SKU_FIELDS : SKU_FIELDS_LITE;						// exclude SKU stock_status_message (garbage html), exclude: HEX_VALUE (should be all strings, some are number types!)			var args : Array = [ {	category:[ categoryId ], category_fields: categoryFields, product: [ ], product_fields: productFields, sku_fields: skuFields } ];			 */			var args : Array = [ {	category:[ categoryId ], category_fields: CATEGORY_FIELDS, product: [ ], product_fields: PRODUCT_FIELDS, sku_fields: SKU_FIELDS } ];			queryRPC( args, categoryResultHandler );		}
		/**		 * Load a Collection's Root Category and return an array of collection 		 * categories for a traditional <code>getProductCollection</code> call.		 * @param rootCategoryId		 * @example <listing version="3.0">		 * ProductFactory.$.getRootCategory( "CAT798" );		 * ProductFactory.$.addEventListener( EngineEvent.QUERY_ROOT_CATEGORY_INIT, rootCategoryHandler );		 * 		 * function rootCategoryHandler(e : Event) : void {		 *  	var catArr : Array = e['data'];		 * }		 * </listing>		 */		public function getRootCategory(categoryId : String) : void {			trace( "ProductFactory.$.getRootCategory( " + categoryId + " ) ..." );			ROOT_CATEGORY = categoryId;			var args : Array = [ {	category:[ categoryId ], category_fields: CATEGORY_FIELDS, product: [], product_fields: [], sku_fields: [] } ];			queryRPC( args, rootCategoryResultHandler );					}
		/**		 * Load a set of categories into a <code>ProductCollection</code>.		 * @param categoryIdArray 	of category ID's to query and inject into the collection.		 * @example <listing version="3.0">		 * ProductFactory.$.getProductCollection( [ "CATEGORY27264", "CATEGORY27265", "CATEGORY27266" ] );		 * ProductFactory.$.addEventListener( EngineEvent.QUERY_COLLECTION_INIT, collectionHandler );		 * 		 * function collectionHandler(e : Event) : void {		 * 		ProductFactory.$.removeEventListener( EngineEvent.QUERY_COLLECTION_INIT );		 * 		var myCollection : ProductCollection = e['data']; // contains the result ProductCollection.		 * }		 * </listing>		 * @see #getProductCategory()		 * @see #getProductItem()		 */		public function getProductCollection(categoryIdArray : Array) : void {			var categoryDictionary : Dictionary = new Dictionary( true );			var pointer : int = -1;						// make a request for the next category collection			var requestCategory : Function = function() : void {				pointer++;				trace( "GET PRODUCT COLLECTION => collecting category item " + categoryIdArray[pointer] + "(" + pointer + ")" );				_instance.addEventListener( EngineEvent.QUERY_CATEGORY_INIT, resultHandler );				getProductCategory( categoryIdArray[pointer] );			};						// handle the result: either make another request or dispatch the compiled collection!			var resultHandler : Function = function(e : Event) : void {				// remove the listener and store the category data.				_instance.removeEventListener( EngineEvent.QUERY_CATEGORY_INIT, resultHandler );				var catData : ProductCategory = e['data'];				categoryDictionary[catData.id] = catData;								if (pointer >= categoryIdArray.length - 1) {					trace( "%%% Collection Assembly Complete Sucessfully!" );					var productCollection : ProductCollection = new ProductCollection( categoryDictionary );					dispatchEvent( new EngineEvent( EngineEvent.QUERY_COLLECTION_INIT, productCollection ) );				} else {					requestCategory( );				}			};						requestCategory( );			}
		//---------------------------------------------------------------------------		// CORE QUERY LOGIC						/**		 * This is the core query wrapper for <code>GenericJsonRpc</code>.		 * @param queryArgs 			array of objects to use as field arguments to JSON call.		 * @param queryResultHandler 	the method which hands the RPC result event: this varies depending on the type of 'getProduct*' methods which called queryRPC.		 * @throws Error 		if an existing query is in-progress.		 */		protected function queryRPC(queryArgs : Array, queryResultHandler : Function) : void {			if ( _isQuerying ) {				throw new Error( 'Engine::ProductFactory has a query in progress: you may only make one query at a time to insure eventListener integrity.' );			}			_queryArgs = queryArgs;			_queryResultHandler = queryResultHandler;			Engine.$.json.addEventListener( GenericJsonRpc.COMPLETE, _queryResultHandler, false, 0, true );			Engine.$.json.addEventListener( GenericJsonRpc.IOERROR, IOErrorHandler, false, 0, true );			Engine.$.json.addEventListener( GenericJsonRpc.TIMERUP, timeoutHandler, false, 0, true );						trace( "!!!!! ProductFactory.$queryRPC() => REMOTE CALL !!!!!" );			//Engine.$.json.doMethod( "prodcat.byid", queryArgs );			//			// added 6/27/08 for inital testing to new DB.			//Engine.$.json.doMethod( "ProductCatalog.manyByPath", queryArgs );			//			// added 8/21/08 for initial testing of new DB wrapper			Engine.$.json.doMethod( 'ProductCatalog.productBrowserData', queryArgs );						//	trace( "!!!!! ProductFactory.$queryRPC() => FAUX LOCAL CALL !!!!!" );			//	var fauxJsonRpcUrl : String = EngineUtil.$.localPathPrefix + '/jsonrpc.php?JSONRPC=' + _queryArgs[0]['category'][0];			//	Engine.$.json.doFauxMethod( fauxJsonRpcUrl );		}
		/**		 * Cleanup the event listeners and prepare for the next query.		 */		protected function queryClean() : void {			_attempts = 0;			_isQuerying = false;			Engine.$.json.removeEventListener( GenericJsonRpc.COMPLETE, _queryResultHandler );			Engine.$.json.removeEventListener( GenericJsonRpc.IOERROR, IOErrorHandler );			Engine.$.json.removeEventListener( GenericJsonRpc.TIMERUP, timeoutHandler );					}
		/**		 * Retry the query if it failed due to IOError or Timeout.		 */		protected function queryRetry() : void {			_attempts++;					if (_attempts >= MAX_ATTEMPTS) {				trace( '!!! - Engine::ProductFactory.$.queryRPC() MAX_ATTEMPTS limit reached: this query has officially failed: Im sorry - I tried.' );				dispatchEvent( new EngineEvent( EngineEvent.QUERY_FAILURE ) );			} else {				queryRPC( _queryArgs, _queryResultHandler );			}		}
		//---------------------------------------------------------------------------		// QUERY RESULT HANDLERS					/**		 * Handle the results from a <code>getProductItem</code> query.		 */		protected function itemResultHandler(e : Event) : void {			queryClean( );			_data = e.target.getResponse( );			trace( "Engine::ProductFactory.$.itemResultHandler() -> " + e );			var productObject : Object = _data['product'][_queryArgs[0].product];			var result : ProductItem = createProductItem( productObject );			dispatchEvent( new EngineEvent( EngineEvent.QUERY_ITEM_INIT, result ) );		}			
		/**		 * Handle the results from a <code>getProductCategory</code> query.		 */		protected function categoryResultHandler(e : Event) : void {			queryClean( );			_data = e.target.getResponse( );			trace( "Engine::ProductFactory.$.categoryResultHandler() -> " + e );						var result : ProductCategory = createProductCategory( _data );			dispatchEvent( new EngineEvent( EngineEvent.QUERY_CATEGORY_INIT, result ) );		}
		/**		 * Handle the results from a <code>getRootCategory</code> query.		 */		protected function rootCategoryResultHandler(e : Event) : void {			queryClean( );			_data = e.target.getResponse( );			trace( "Engine::ProductFactory.$.rootCategoryResultHandler() -> " + e );			var result : Array = new Array( );			// locate the category array ...			for each (var i : * in  _data['category']) {				if(ROOT_CATEGORY == i.category_id) {					result = i.category;					// add the root category to the top of the array					result.unshift( i.category_id );					//trace( "collectionCategories: " + i.category + ' (length: ' + i.category.length + ")" );					break;				}			}			ROOT_CATEGORY = null;			dispatchEvent( new EngineEvent( EngineEvent.QUERY_ROOT_CATEGORY_INIT, result ) );		}		
		/**		 * Handle the results from a <code>getProductCollection</code> query.		 */		protected function collectionResultHandler(e : Event) : void {			trace( "Engine::ProductFactory.$.collectionResultHandler() -> " + e );			}
		/**		 * Handle query Timeouts.		 */		protected function timeoutHandler(e : Event = null) : void {			trace( "Engine::ProductFactory.timeoutHandler: " + e );			queryRetry( );		}
		/**		 * Handle query <code>IOError</code>'s.		 */		protected function IOErrorHandler(e : Event) : void {			trace( "Engine::ProductFactory.IOErrorHandler: " + e );			queryRetry( );		}
		//---------------------------------------------------------------------------		// PRODUCT OBJECT GENERATORS				/**		 * @private - Create an array of 1-4 random hex values.		protected function createFauxHex() : Array {			var a : Array = new Array( );		var amount : uint = Math.round( Math.random( ) * (4 - 1) ) + 1;		for (var i : int = 0; i < amount ; i++) {		a.push( String( "0x" + Math.floor( Math.random( ) * 16777215 ).toString( 16 ).toUpperCase( ) ) );		}		return a;		}		 */		 		/**		 * Generate a new <code>ProductCategory</code> instance (including ProductItem Dictionary) from raw JSON data.		 * NOTE: This parser assumes a single category json result object.		 */		protected function createProductCategory(data : *) : ProductCategory {						// productDictionary inside the ProductCategory.			var productDictionary : Dictionary = new Dictionary( true );			if (!_data.product) {				trace( '!!! - Engine::ProductFactory.$.createProductCategory() StockLookup Error: no product data available ...' );			}						// parse out the category id and display name						var catId : String = _queryArgs[0].category[0];			// was: var displayName : String = data.category[catId].DISPLAY_NAME;			//var displayName : String = data.category[catId].display_name;			var displayName : String = data.category[catId].category_name;			var baseName : String = data.category[catId].image_name;									// PRODUCT LOOP: Iterate through each Product in the Category & create a ProductItem instance 			// for each: inject a dictionary of ProductItem instances inside the ProductCategory ...			for each (var product:* in data.product) {				productDictionary[product.product_id] = createProductItem( product );				}			// CREATE & RETURN the ProductCategory			var productCategory : ProductCategory = new ProductCategory( catId, EngineUtil.$.sanitizeStr( displayName ), EngineUtil.$.sanitizeStr( baseName ), productDictionary );					return productCategory;		}
		/**		 * Generate a new <code>ProductItem</code> instance (including SkuItem Dictionary) from raw JSON data.		 * NOTE: This parser assumes a single category json result object.		 */		protected function createProductItem(product : *) : ProductItem {			// skuDictionary inside the ProductItem(s).			var skuDictionary : Dictionary = new Dictionary( true );			if (!_data.sku) {				trace( '!!! - Engine::ProductFactory.$.createProductItem() StockLookup Error: no sku data available ...' );			} 			// SKU LOOP: Iterate through each Sku in the Product & create a ProductSku instance			// for each: inject a dictionary of ProductSku instances in each ProductItem ...			for each (var sku:* in product.sku) {				//trace( 'skudata id: ' + sku + "\nskudata raw: " + _data.sku[sku] );				var skuData : * = _data.sku[sku];								var key : String = sku as String;								//var id : String = skuData.SKU_ID;				var id : String = skuData.sku_id;								//var price : int = skuData.PRODUCT_PRICE;				//var price : int = parseInt( skuData.price );				var price : Number = Number( skuData.price );								//var size : String = EngineUtil.$.sanitizeStr( skuData.PRODUCT_SIZE );				var size : String = EngineUtil.$.sanitizeStr( skuData.size );								//var code : String = EngineUtil.$.sanitizeStr( skuData.PRODUCT_CODE );				var code : String = EngineUtil.$.sanitizeStr( skuData.product_code );								// inject a fake array of color strings.				//var hex : Array = createFauxHex( );				//var hex : Array = skuData.HEX_VALUE;								// direct array of strings ...				//var hex : Array = skuData.hex_values;								// converted array of uints ...				var hex : Array = new Array( );				for (var i : int = 0; i < skuData.hex_values.length ; i++) hex.push( parseInt( String( '0x' + skuData.hex_values[i] ) ) );								//var upc : int = skuData.UPC_CODE;				var upc : int = parseInt( skuData.upc_code );								// Remapped to productData image_base (sooooooooo sooooo)				//var imageBase : String = EngineUtil.$.sanitizeStr( skuData.IMAGE_BASE );				var imageBase : String = EngineUtil.$.sanitizeStr( product.image_base );								//var smoosh : String = EngineUtil.$.sanitizeStr( skuData.SMOOSH_DESIGN );				var smoosh : String = EngineUtil.$.sanitizeStr( skuData.smoosh_design );								//var description : String = EngineUtil.$.sanitizeStr( skuData.DESCRIPTION );				//var description : String = EngineUtil.$.sanitizeStr( product.flash_desc );				var description : String = EngineUtil.$.sanitizeStr( skuData.flash_desc );				// DEPRECATED				//var shortDesc : String = EngineUtil.$.sanitizeStr( skuData.SHORT_DESC );				//var lowerDesc : String = EngineUtil.$.sanitizeStr( skuData.LOWER_DESC );				//var subHeading : String = EngineUtil.$.sanitizeStr( skuData.SUB_HEADING );								// DEPRECATED				//var benefits : String = EngineUtil.$.sanitizeStr( skuData.benefit );								// DEPRECATED				//var features : String = EngineUtil.$.sanitizeStr( skuData.FEATURES );								//var finish : String = EngineUtil.$.sanitizeStr( skuData.FINISH );				var finish : String = EngineUtil.$.sanitizeStr( skuData.finish );								//var shadeName : String = EngineUtil.$.sanitizeStr( skuData.SHADENAME );				var shadeName : String = EngineUtil.$.sanitizeStr( skuData.shadename );								// DEPRECATED				//var shadeGroup : String = EngineUtil.$.sanitizeStr( skuData.SHADE_GROUP );								// var shadeDescription : String = EngineUtil.$.sanitizeStr( skuData.SHADE_DESCRIPTION );				var shadeDescription : String = EngineUtil.$.sanitizeStr( skuData.shade_description );								// DEPRECATED				//var skinTypeDry : int = skuData.EL_SKIN_TYPE_DRY;				//var skinTypeOily : int = skuData.EL_SKIN_TYPE_OILY;				//var skinTypeCombo : int = skuData.EL_SKIN_TYPE_COMBO;								// var inventoryStatus : String = EngineUtil.$.sanitizeStr( skuData.INVENTORY_STATUS );				var inventoryStatus : String = EngineUtil.$.sanitizeStr( skuData.inventory_status );				// DEPRECATED				//var shoppingId : int = skuData.shopping_id;				// DEPRECATED				//var shoppable : int = skuData.shoppable;								// TENDER custom fields								// var area_id : Array = skuData.area_id;				var area_id : Array = skuData.area_of_face;					// var product_form_id : Array = skuData.product_form_id;					var product_form_id : Array = skuData.product_form;									// var product_type_id : Array = skuData.product_type_id;				var product_type_id : Array = skuData.product_type;									//var coverage_id : Array = skuData.coverage_id;					var coverage_id : Array = skuData.coverage;									// var finish_id : Array = skuData.finish_id;					var finish_id : Array = skuData.finish_simple;								//var undertone_id : Array = skuData.undertone_id;					var undertone_id : Array = skuData.undertone;								//var use_id : Array = skuData.use_id;				var use_id : Array = skuData['use'];									//var use_with_id : Array = skuData.use_with_id;				var use_with_id : Array = skuData.use_with;									//var fibre_id : Array = skuData.fibre_id;				var fibre_id : Array = skuData.fibre;									// DEPRECATED				//var benefit_id : Array = skuData.benefit_id;								//var intensity : uint = skuData.intensity;				var intensity : uint = parseInt( skuData.intensity );									// replicate this down to the sku level to simplify tracking in various applications				var default_category : String = product.default_cat_id;							// CREATE the skuItem				skuDictionary[id] = new ProductSku( key, id, price, size, code, hex, upc, imageBase, smoosh, description, finish, shadeName, shadeDescription, inventoryStatus, area_id, product_type_id, product_form_id, coverage_id, finish_id, undertone_id, use_id, use_with_id, fibre_id, intensity, default_category );			}									// CREATE & RETURN the ProductItem			//var productItem : ProductItem = new ProductItem( product.PRODUCT_ID, EngineUtil.$.sanitizeStr( product.PRODUCT_NAME ), EngineUtil.$.sanitizeStr( product.DESCRIPTION ), EngineUtil.$.sanitizeStr( product.IMAGE_NAME ), product.finishes_by_product, skuDictionary );			var productItem : ProductItem = new ProductItem( product.product_id, EngineUtil.$.sanitizeStr( product.name ), EngineUtil.$.sanitizeStr( product.description ), EngineUtil.$.sanitizeStr( product.image_base ), product.finishes_by_product, product.default_cat_id, skuDictionary );			return productItem;		}				//---------------------------------------------------------------------------	}}
/** * Internal class is accessible only to this AS fileand is used  * as a constructor param to enforce proper Singleton behavior. */internal class SingletonEnforcer {}			